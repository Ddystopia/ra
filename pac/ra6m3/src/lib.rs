/*!Peripheral access API for R7FA6M3AH microcontrollers (generated using svd2rust v0.36.1 ( ))

You can find an overview of the generated API [here].

API features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.

[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api
[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
[repository]: https://github.com/rust-embedded/svd2rust*/
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
///Number available in the NVIC for configuring priority
pub const NVIC_PRIO_BITS: u8 = 4;
#[allow(unused_imports)]
use generic::*;
///Common register and bit access and modify traits
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn IEL0();
    fn IEL1();
    fn IEL2();
    fn IEL3();
    fn IEL4();
    fn IEL5();
    fn IEL6();
    fn IEL7();
    fn IEL8();
    fn IEL9();
    fn IEL10();
    fn IEL11();
    fn IEL12();
    fn IEL13();
    fn IEL14();
    fn IEL15();
    fn IEL16();
    fn IEL17();
    fn IEL18();
    fn IEL19();
    fn IEL20();
    fn IEL21();
    fn IEL22();
    fn IEL23();
    fn IEL24();
    fn IEL25();
    fn IEL26();
    fn IEL27();
    fn IEL28();
    fn IEL29();
    fn IEL30();
    fn IEL31();
    fn IEL32();
    fn IEL33();
    fn IEL34();
    fn IEL35();
    fn IEL36();
    fn IEL37();
    fn IEL38();
    fn IEL39();
    fn IEL40();
    fn IEL41();
    fn IEL42();
    fn IEL43();
    fn IEL44();
    fn IEL45();
    fn IEL46();
    fn IEL47();
    fn IEL48();
    fn IEL49();
    fn IEL50();
    fn IEL51();
    fn IEL52();
    fn IEL53();
    fn IEL54();
    fn IEL55();
    fn IEL56();
    fn IEL57();
    fn IEL58();
    fn IEL59();
    fn IEL60();
    fn IEL61();
    fn IEL62();
    fn IEL63();
    fn IEL64();
    fn IEL65();
    fn IEL66();
    fn IEL67();
    fn IEL68();
    fn IEL69();
    fn IEL70();
    fn IEL71();
    fn IEL72();
    fn IEL73();
    fn IEL74();
    fn IEL75();
    fn IEL76();
    fn IEL77();
    fn IEL78();
    fn IEL79();
    fn IEL80();
    fn IEL81();
    fn IEL82();
    fn IEL83();
    fn IEL84();
    fn IEL85();
    fn IEL86();
    fn IEL87();
    fn IEL88();
    fn IEL89();
    fn IEL90();
    fn IEL91();
    fn IEL92();
    fn IEL93();
    fn IEL94();
    fn IEL95();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 96] = [
    Vector { _handler: IEL0 },
    Vector { _handler: IEL1 },
    Vector { _handler: IEL2 },
    Vector { _handler: IEL3 },
    Vector { _handler: IEL4 },
    Vector { _handler: IEL5 },
    Vector { _handler: IEL6 },
    Vector { _handler: IEL7 },
    Vector { _handler: IEL8 },
    Vector { _handler: IEL9 },
    Vector { _handler: IEL10 },
    Vector { _handler: IEL11 },
    Vector { _handler: IEL12 },
    Vector { _handler: IEL13 },
    Vector { _handler: IEL14 },
    Vector { _handler: IEL15 },
    Vector { _handler: IEL16 },
    Vector { _handler: IEL17 },
    Vector { _handler: IEL18 },
    Vector { _handler: IEL19 },
    Vector { _handler: IEL20 },
    Vector { _handler: IEL21 },
    Vector { _handler: IEL22 },
    Vector { _handler: IEL23 },
    Vector { _handler: IEL24 },
    Vector { _handler: IEL25 },
    Vector { _handler: IEL26 },
    Vector { _handler: IEL27 },
    Vector { _handler: IEL28 },
    Vector { _handler: IEL29 },
    Vector { _handler: IEL30 },
    Vector { _handler: IEL31 },
    Vector { _handler: IEL32 },
    Vector { _handler: IEL33 },
    Vector { _handler: IEL34 },
    Vector { _handler: IEL35 },
    Vector { _handler: IEL36 },
    Vector { _handler: IEL37 },
    Vector { _handler: IEL38 },
    Vector { _handler: IEL39 },
    Vector { _handler: IEL40 },
    Vector { _handler: IEL41 },
    Vector { _handler: IEL42 },
    Vector { _handler: IEL43 },
    Vector { _handler: IEL44 },
    Vector { _handler: IEL45 },
    Vector { _handler: IEL46 },
    Vector { _handler: IEL47 },
    Vector { _handler: IEL48 },
    Vector { _handler: IEL49 },
    Vector { _handler: IEL50 },
    Vector { _handler: IEL51 },
    Vector { _handler: IEL52 },
    Vector { _handler: IEL53 },
    Vector { _handler: IEL54 },
    Vector { _handler: IEL55 },
    Vector { _handler: IEL56 },
    Vector { _handler: IEL57 },
    Vector { _handler: IEL58 },
    Vector { _handler: IEL59 },
    Vector { _handler: IEL60 },
    Vector { _handler: IEL61 },
    Vector { _handler: IEL62 },
    Vector { _handler: IEL63 },
    Vector { _handler: IEL64 },
    Vector { _handler: IEL65 },
    Vector { _handler: IEL66 },
    Vector { _handler: IEL67 },
    Vector { _handler: IEL68 },
    Vector { _handler: IEL69 },
    Vector { _handler: IEL70 },
    Vector { _handler: IEL71 },
    Vector { _handler: IEL72 },
    Vector { _handler: IEL73 },
    Vector { _handler: IEL74 },
    Vector { _handler: IEL75 },
    Vector { _handler: IEL76 },
    Vector { _handler: IEL77 },
    Vector { _handler: IEL78 },
    Vector { _handler: IEL79 },
    Vector { _handler: IEL80 },
    Vector { _handler: IEL81 },
    Vector { _handler: IEL82 },
    Vector { _handler: IEL83 },
    Vector { _handler: IEL84 },
    Vector { _handler: IEL85 },
    Vector { _handler: IEL86 },
    Vector { _handler: IEL87 },
    Vector { _handler: IEL88 },
    Vector { _handler: IEL89 },
    Vector { _handler: IEL90 },
    Vector { _handler: IEL91 },
    Vector { _handler: IEL92 },
    Vector { _handler: IEL93 },
    Vector { _handler: IEL94 },
    Vector { _handler: IEL95 },
];
///Enumeration of all the interrupts.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    ///0 - ICU Interrupt 0
    IEL0 = 0,
    ///1 - ICU Interrupt 1
    IEL1 = 1,
    ///2 - ICU Interrupt 2
    IEL2 = 2,
    ///3 - ICU Interrupt 3
    IEL3 = 3,
    ///4 - ICU Interrupt 4
    IEL4 = 4,
    ///5 - ICU Interrupt 5
    IEL5 = 5,
    ///6 - ICU Interrupt 6
    IEL6 = 6,
    ///7 - ICU Interrupt 7
    IEL7 = 7,
    ///8 - ICU Interrupt 8
    IEL8 = 8,
    ///9 - ICU Interrupt 9
    IEL9 = 9,
    ///10 - ICU Interrupt 10
    IEL10 = 10,
    ///11 - ICU Interrupt 11
    IEL11 = 11,
    ///12 - ICU Interrupt 12
    IEL12 = 12,
    ///13 - ICU Interrupt 13
    IEL13 = 13,
    ///14 - ICU Interrupt 14
    IEL14 = 14,
    ///15 - ICU Interrupt 15
    IEL15 = 15,
    ///16 - ICU Interrupt 16
    IEL16 = 16,
    ///17 - ICU Interrupt 17
    IEL17 = 17,
    ///18 - ICU Interrupt 18
    IEL18 = 18,
    ///19 - ICU Interrupt 19
    IEL19 = 19,
    ///20 - ICU Interrupt 20
    IEL20 = 20,
    ///21 - ICU Interrupt 21
    IEL21 = 21,
    ///22 - ICU Interrupt 22
    IEL22 = 22,
    ///23 - ICU Interrupt 23
    IEL23 = 23,
    ///24 - ICU Interrupt 24
    IEL24 = 24,
    ///25 - ICU Interrupt 25
    IEL25 = 25,
    ///26 - ICU Interrupt 26
    IEL26 = 26,
    ///27 - ICU Interrupt 27
    IEL27 = 27,
    ///28 - ICU Interrupt 28
    IEL28 = 28,
    ///29 - ICU Interrupt 29
    IEL29 = 29,
    ///30 - ICU Interrupt 30
    IEL30 = 30,
    ///31 - ICU Interrupt 31
    IEL31 = 31,
    ///32 - ICU Interrupt 32
    IEL32 = 32,
    ///33 - ICU Interrupt 33
    IEL33 = 33,
    ///34 - ICU Interrupt 34
    IEL34 = 34,
    ///35 - ICU Interrupt 35
    IEL35 = 35,
    ///36 - ICU Interrupt 36
    IEL36 = 36,
    ///37 - ICU Interrupt 37
    IEL37 = 37,
    ///38 - ICU Interrupt 38
    IEL38 = 38,
    ///39 - ICU Interrupt 39
    IEL39 = 39,
    ///40 - ICU Interrupt 40
    IEL40 = 40,
    ///41 - ICU Interrupt 41
    IEL41 = 41,
    ///42 - ICU Interrupt 42
    IEL42 = 42,
    ///43 - ICU Interrupt 43
    IEL43 = 43,
    ///44 - ICU Interrupt 44
    IEL44 = 44,
    ///45 - ICU Interrupt 45
    IEL45 = 45,
    ///46 - ICU Interrupt 46
    IEL46 = 46,
    ///47 - ICU Interrupt 47
    IEL47 = 47,
    ///48 - ICU Interrupt 48
    IEL48 = 48,
    ///49 - ICU Interrupt 49
    IEL49 = 49,
    ///50 - ICU Interrupt 50
    IEL50 = 50,
    ///51 - ICU Interrupt 51
    IEL51 = 51,
    ///52 - ICU Interrupt 52
    IEL52 = 52,
    ///53 - ICU Interrupt 53
    IEL53 = 53,
    ///54 - ICU Interrupt 54
    IEL54 = 54,
    ///55 - ICU Interrupt 55
    IEL55 = 55,
    ///56 - ICU Interrupt 56
    IEL56 = 56,
    ///57 - ICU Interrupt 57
    IEL57 = 57,
    ///58 - ICU Interrupt 58
    IEL58 = 58,
    ///59 - ICU Interrupt 59
    IEL59 = 59,
    ///60 - ICU Interrupt 60
    IEL60 = 60,
    ///61 - ICU Interrupt 61
    IEL61 = 61,
    ///62 - ICU Interrupt 62
    IEL62 = 62,
    ///63 - ICU Interrupt 63
    IEL63 = 63,
    ///64 - ICU Interrupt 64
    IEL64 = 64,
    ///65 - ICU Interrupt 65
    IEL65 = 65,
    ///66 - ICU Interrupt 66
    IEL66 = 66,
    ///67 - ICU Interrupt 67
    IEL67 = 67,
    ///68 - ICU Interrupt 68
    IEL68 = 68,
    ///69 - ICU Interrupt 69
    IEL69 = 69,
    ///70 - ICU Interrupt 70
    IEL70 = 70,
    ///71 - ICU Interrupt 71
    IEL71 = 71,
    ///72 - ICU Interrupt 72
    IEL72 = 72,
    ///73 - ICU Interrupt 73
    IEL73 = 73,
    ///74 - ICU Interrupt 74
    IEL74 = 74,
    ///75 - ICU Interrupt 75
    IEL75 = 75,
    ///76 - ICU Interrupt 76
    IEL76 = 76,
    ///77 - ICU Interrupt 77
    IEL77 = 77,
    ///78 - ICU Interrupt 78
    IEL78 = 78,
    ///79 - ICU Interrupt 79
    IEL79 = 79,
    ///80 - ICU Interrupt 80
    IEL80 = 80,
    ///81 - ICU Interrupt 81
    IEL81 = 81,
    ///82 - ICU Interrupt 82
    IEL82 = 82,
    ///83 - ICU Interrupt 83
    IEL83 = 83,
    ///84 - ICU Interrupt 84
    IEL84 = 84,
    ///85 - ICU Interrupt 85
    IEL85 = 85,
    ///86 - ICU Interrupt 86
    IEL86 = 86,
    ///87 - ICU Interrupt 87
    IEL87 = 87,
    ///88 - ICU Interrupt 88
    IEL88 = 88,
    ///89 - ICU Interrupt 89
    IEL89 = 89,
    ///90 - ICU Interrupt 90
    IEL90 = 90,
    ///91 - ICU Interrupt 91
    IEL91 = 91,
    ///92 - ICU Interrupt 92
    IEL92 = 92,
    ///93 - ICU Interrupt 93
    IEL93 = 93,
    ///94 - ICU Interrupt 94
    IEL94 = 94,
    ///95 - ICU Interrupt 95
    IEL95 = 95,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
///Port 0 Control Registers
pub type PORT0 = crate::Periph<port0::RegisterBlock, 0x4004_0000>;
impl core::fmt::Debug for PORT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT0").finish()
    }
}
///Port 0 Control Registers
pub mod port0;
///Port 1 Control Registers
pub type PORT1 = crate::Periph<port1::RegisterBlock, 0x4004_0020>;
impl core::fmt::Debug for PORT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT1").finish()
    }
}
///Port 1 Control Registers
pub mod port1;
///Port 2 Control Registers
pub type PORT2 = crate::Periph<port1::RegisterBlock, 0x4004_0040>;
impl core::fmt::Debug for PORT2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT2").finish()
    }
}
///Port 2 Control Registers
pub use self::port1 as port2;
///Port 3 Control Registers
pub type PORT3 = crate::Periph<port1::RegisterBlock, 0x4004_0060>;
impl core::fmt::Debug for PORT3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT3").finish()
    }
}
///Port 3 Control Registers
pub use self::port1 as port3;
///Port 4 Control Registers
pub type PORT4 = crate::Periph<port1::RegisterBlock, 0x4004_0080>;
impl core::fmt::Debug for PORT4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT4").finish()
    }
}
///Port 4 Control Registers
pub use self::port1 as port4;
///Port 5 Control Registers
pub type PORT5 = crate::Periph<port0::RegisterBlock, 0x4004_00a0>;
impl core::fmt::Debug for PORT5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT5").finish()
    }
}
///Port 5 Control Registers
pub use self::port0 as port5;
///Port 6 Control Registers
pub type PORT6 = crate::Periph<port0::RegisterBlock, 0x4004_00c0>;
impl core::fmt::Debug for PORT6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT6").finish()
    }
}
///Port 6 Control Registers
pub use self::port0 as port6;
///Port 7 Control Registers
pub type PORT7 = crate::Periph<port0::RegisterBlock, 0x4004_00e0>;
impl core::fmt::Debug for PORT7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT7").finish()
    }
}
///Port 7 Control Registers
pub use self::port0 as port7;
///Port 8 Control Registers
pub type PORT8 = crate::Periph<port0::RegisterBlock, 0x4004_0100>;
impl core::fmt::Debug for PORT8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT8").finish()
    }
}
///Port 8 Control Registers
pub use self::port0 as port8;
///Port 9 Control Registers
pub type PORT9 = crate::Periph<port0::RegisterBlock, 0x4004_0120>;
impl core::fmt::Debug for PORT9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORT9").finish()
    }
}
///Port 9 Control Registers
pub use self::port0 as port9;
///Port A Control Registers
pub type PORTA = crate::Periph<port0::RegisterBlock, 0x4004_0140>;
impl core::fmt::Debug for PORTA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORTA").finish()
    }
}
///Port A Control Registers
pub use self::port0 as porta;
///Port B Control Registers
pub type PORTB = crate::Periph<port0::RegisterBlock, 0x4004_0160>;
impl core::fmt::Debug for PORTB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PORTB").finish()
    }
}
///Port B Control Registers
pub use self::port0 as portb;
///Pmn Pin Function Control Register
pub type PFS = crate::Periph<pfs::RegisterBlock, 0x4004_0800>;
impl core::fmt::Debug for PFS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFS").finish()
    }
}
///Pmn Pin Function Control Register
pub mod pfs;
///Miscellaneous Port Control Register
pub type PMISC = crate::Periph<pmisc::RegisterBlock, 0x4004_0d00>;
impl core::fmt::Debug for PMISC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PMISC").finish()
    }
}
///Miscellaneous Port Control Register
pub mod pmisc;
///Serial Peripheral Interface 0
pub type SPI0 = crate::Periph<spi0::RegisterBlock, 0x4007_2000>;
impl core::fmt::Debug for SPI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI0").finish()
    }
}
///Serial Peripheral Interface 0
pub mod spi0;
///Serial Peripheral Interface 1
pub type SPI1 = crate::Periph<spi0::RegisterBlock, 0x4007_2100>;
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///Serial Peripheral Interface 1
pub use self::spi0 as spi1;
///Output Phase Switching Controller
pub type GPT_OPS = crate::Periph<gpt_ops::RegisterBlock, 0x4007_8ff0>;
impl core::fmt::Debug for GPT_OPS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT_OPS").finish()
    }
}
///Output Phase Switching Controller
pub mod gpt_ops;
///General PWM Timer 0 (32-bit Enhanced High Resolution)
pub type GPT32EH0 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8000>;
impl core::fmt::Debug for GPT32EH0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32EH0").finish()
    }
}
///General PWM Timer 0 (32-bit Enhanced High Resolution)
pub mod gpt32eh0;
///General PWM Timer 1 (32-bit Enhanced High Resolution)
pub type GPT32EH1 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8100>;
impl core::fmt::Debug for GPT32EH1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32EH1").finish()
    }
}
///General PWM Timer 1 (32-bit Enhanced High Resolution)
pub use self::gpt32eh0 as gpt32eh1;
///General PWM Timer 2 (32-bit Enhanced High Resolution)
pub type GPT32EH2 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8200>;
impl core::fmt::Debug for GPT32EH2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32EH2").finish()
    }
}
///General PWM Timer 2 (32-bit Enhanced High Resolution)
pub use self::gpt32eh0 as gpt32eh2;
///General PWM Timer 3 (32-bit Enhanced High Resolution)
pub type GPT32EH3 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8300>;
impl core::fmt::Debug for GPT32EH3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32EH3").finish()
    }
}
///General PWM Timer 3 (32-bit Enhanced High Resolution)
pub use self::gpt32eh0 as gpt32eh3;
///General PWM Timer 4 (32-bit Enhanced)
pub type GPT32E4 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8400>;
impl core::fmt::Debug for GPT32E4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32E4").finish()
    }
}
///General PWM Timer 4 (32-bit Enhanced)
pub use self::gpt32eh0 as gpt32e4;
///General PWM Timer 5 (32-bit Enhanced)
pub type GPT32E5 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8500>;
impl core::fmt::Debug for GPT32E5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32E5").finish()
    }
}
///General PWM Timer 5 (32-bit Enhanced)
pub use self::gpt32eh0 as gpt32e5;
///General PWM Timer 6 (32-bit Enhanced)
pub type GPT32E6 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8600>;
impl core::fmt::Debug for GPT32E6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32E6").finish()
    }
}
///General PWM Timer 6 (32-bit Enhanced)
pub use self::gpt32eh0 as gpt32e6;
///General PWM Timer 7 (32-bit Enhanced)
pub type GPT32E7 = crate::Periph<gpt32eh0::RegisterBlock, 0x4007_8700>;
impl core::fmt::Debug for GPT32E7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT32E7").finish()
    }
}
///General PWM Timer 7 (32-bit Enhanced)
pub use self::gpt32eh0 as gpt32e7;
///Graphics LCD Controller
pub type GLCDC = crate::Periph<glcdc::RegisterBlock, 0x400e_0000>;
impl core::fmt::Debug for GLCDC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GLCDC").finish()
    }
}
///Graphics LCD Controller
pub mod glcdc;
///2D Drawing Engine
pub type DRW = crate::Periph<drw::RegisterBlock, 0x400e_4000>;
impl core::fmt::Debug for DRW {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DRW").finish()
    }
}
///2D Drawing Engine
pub mod drw;
///USB 2.0 High-Speed Module
pub type USBHS = crate::Periph<usbhs::RegisterBlock, 0x4006_0000>;
impl core::fmt::Debug for USBHS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBHS").finish()
    }
}
///USB 2.0 High-Speed Module
pub mod usbhs;
///Serial Communication Interface 0
pub type SCI0 = crate::Periph<sci0::RegisterBlock, 0x4007_0000>;
impl core::fmt::Debug for SCI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI0").finish()
    }
}
///Serial Communication Interface 0
pub mod sci0;
///Serial Communication Interface 1
pub type SCI1 = crate::Periph<sci0::RegisterBlock, 0x4007_0020>;
impl core::fmt::Debug for SCI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI1").finish()
    }
}
///Serial Communication Interface 1
pub use self::sci0 as sci1;
///Serial Communication Interface 2
pub type SCI2 = crate::Periph<sci0::RegisterBlock, 0x4007_0040>;
impl core::fmt::Debug for SCI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI2").finish()
    }
}
///Serial Communication Interface 2
pub use self::sci0 as sci2;
///Serial Communication Interface 3
pub type SCI3 = crate::Periph<sci0::RegisterBlock, 0x4007_0060>;
impl core::fmt::Debug for SCI3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI3").finish()
    }
}
///Serial Communication Interface 3
pub use self::sci0 as sci3;
///Serial Communication Interface 4
pub type SCI4 = crate::Periph<sci0::RegisterBlock, 0x4007_0080>;
impl core::fmt::Debug for SCI4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI4").finish()
    }
}
///Serial Communication Interface 4
pub use self::sci0 as sci4;
///Serial Communication Interface 5
pub type SCI5 = crate::Periph<sci0::RegisterBlock, 0x4007_00a0>;
impl core::fmt::Debug for SCI5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI5").finish()
    }
}
///Serial Communication Interface 5
pub use self::sci0 as sci5;
///Serial Communication Interface 6
pub type SCI6 = crate::Periph<sci0::RegisterBlock, 0x4007_00c0>;
impl core::fmt::Debug for SCI6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI6").finish()
    }
}
///Serial Communication Interface 6
pub use self::sci0 as sci6;
///Serial Communication Interface 7
pub type SCI7 = crate::Periph<sci0::RegisterBlock, 0x4007_00e0>;
impl core::fmt::Debug for SCI7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI7").finish()
    }
}
///Serial Communication Interface 7
pub use self::sci0 as sci7;
///Serial Communication Interface 8
pub type SCI8 = crate::Periph<sci0::RegisterBlock, 0x4007_0100>;
impl core::fmt::Debug for SCI8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI8").finish()
    }
}
///Serial Communication Interface 8
pub use self::sci0 as sci8;
///Serial Communication Interface 9
pub type SCI9 = crate::Periph<sci0::RegisterBlock, 0x4007_0120>;
impl core::fmt::Debug for SCI9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCI9").finish()
    }
}
///Serial Communication Interface 9
pub use self::sci0 as sci9;
///Inter-Integrated Circuit 0
pub type IIC0 = crate::Periph<iic0::RegisterBlock, 0x4005_3000>;
impl core::fmt::Debug for IIC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IIC0").finish()
    }
}
///Inter-Integrated Circuit 0
pub mod iic0;
///Inter-Integrated Circuit 1
pub type IIC1 = crate::Periph<iic1::RegisterBlock, 0x4005_3100>;
impl core::fmt::Debug for IIC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IIC1").finish()
    }
}
///Inter-Integrated Circuit 1
pub mod iic1;
///Inter-Integrated Circuit 2
pub type IIC2 = crate::Periph<iic1::RegisterBlock, 0x4005_3200>;
impl core::fmt::Debug for IIC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IIC2").finish()
    }
}
///Inter-Integrated Circuit 2
pub use self::iic1 as iic2;
///System Control
pub type SYSTEM = crate::Periph<system::RegisterBlock, 0x4001_e000>;
impl core::fmt::Debug for SYSTEM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTEM").finish()
    }
}
///System Control
pub mod system;
///DMA Controller for the Ethernet Controller Channel 0
pub type EDMAC0 = crate::Periph<edmac0::RegisterBlock, 0x4006_4000>;
impl core::fmt::Debug for EDMAC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EDMAC0").finish()
    }
}
///DMA Controller for the Ethernet Controller Channel 0
pub mod edmac0;
///Ethernet Controller Channel 0
pub type ETHERC0 = crate::Periph<etherc0::RegisterBlock, 0x4006_4100>;
impl core::fmt::Debug for ETHERC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ETHERC0").finish()
    }
}
///Ethernet Controller Channel 0
pub mod etherc0;
///DMA Controller for EPTPC
pub type PTPEDMAC = crate::Periph<ptpedmac::RegisterBlock, 0x4006_4400>;
impl core::fmt::Debug for PTPEDMAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PTPEDMAC").finish()
    }
}
///DMA Controller for EPTPC
pub mod ptpedmac;
///PTP Module for the Ethernet Controller
pub type EPTPC = crate::Periph<eptpc::RegisterBlock, 0x4006_5000>;
impl core::fmt::Debug for EPTPC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EPTPC").finish()
    }
}
///PTP Module for the Ethernet Controller
pub mod eptpc;
///PTP Module 0 for the Ethernet Controller
pub type EPTPC0 = crate::Periph<eptpc0::RegisterBlock, 0x4006_5800>;
impl core::fmt::Debug for EPTPC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EPTPC0").finish()
    }
}
///PTP Module 0 for the Ethernet Controller
pub mod eptpc0;
///EPTPC Configulation
pub type EPTPC_CFG = crate::Periph<eptpc_cfg::RegisterBlock, 0x4006_4500>;
impl core::fmt::Debug for EPTPC_CFG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EPTPC_CFG").finish()
    }
}
///EPTPC Configulation
pub mod eptpc_cfg;
///SD Host Interface 0
pub type SDHI0 = crate::Periph<sdhi0::RegisterBlock, 0x4006_2000>;
impl core::fmt::Debug for SDHI0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SDHI0").finish()
    }
}
///SD Host Interface 0
pub mod sdhi0;
///SD Host Interface 1
pub type SDHI1 = crate::Periph<sdhi0::RegisterBlock, 0x4006_2400>;
impl core::fmt::Debug for SDHI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SDHI1").finish()
    }
}
///SD Host Interface 1
pub use self::sdhi0 as sdhi1;
///CRC Calculator
pub type CRC = crate::Periph<crc::RegisterBlock, 0x4007_4000>;
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
///CRC Calculator
pub mod crc;
///Capacitive Touch Sensing Unit
pub type CTSU = crate::Periph<ctsu::RegisterBlock, 0x4008_1000>;
impl core::fmt::Debug for CTSU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CTSU").finish()
    }
}
///Capacitive Touch Sensing Unit
pub mod ctsu;
///Bus Master MPU
pub type MMPU = crate::Periph<mmpu::RegisterBlock, 0x4000_0000>;
impl core::fmt::Debug for MMPU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MMPU").finish()
    }
}
///Bus Master MPU
pub mod mmpu;
///Bus Slave MPU
pub type SMPU = crate::Periph<smpu::RegisterBlock, 0x4000_0c00>;
impl core::fmt::Debug for SMPU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SMPU").finish()
    }
}
///Bus Slave MPU
pub mod smpu;
///CPU Stack Pointer Monitor
pub type SPMON = crate::Periph<spmon::RegisterBlock, 0x4000_0d00>;
impl core::fmt::Debug for SPMON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPMON").finish()
    }
}
///CPU Stack Pointer Monitor
pub mod spmon;
///12bit A/D Converter 0
pub type ADC120 = crate::Periph<adc120::RegisterBlock, 0x4005_c000>;
impl core::fmt::Debug for ADC120 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC120").finish()
    }
}
///12bit A/D Converter 0
pub mod adc120;
///12bit A/D Converter 1
pub type ADC121 = crate::Periph<adc121::RegisterBlock, 0x4005_c200>;
impl core::fmt::Debug for ADC121 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC121").finish()
    }
}
///12bit A/D Converter 1
pub mod adc121;
///Module Stop Control B,C,D
pub type MSTP = crate::Periph<mstp::RegisterBlock, 0x4004_7000>;
impl core::fmt::Debug for MSTP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MSTP").finish()
    }
}
///Module Stop Control B,C,D
pub mod mstp;
///General PWM Timer 8 (32-bit Enhanced)
pub type GPT328 = crate::Periph<gpt328::RegisterBlock, 0x4007_8800>;
impl core::fmt::Debug for GPT328 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT328").finish()
    }
}
///General PWM Timer 8 (32-bit Enhanced)
pub mod gpt328;
///General PWM Timer 9 (32-bit Enhanced)
pub type GPT329 = crate::Periph<gpt328::RegisterBlock, 0x4007_8900>;
impl core::fmt::Debug for GPT329 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT329").finish()
    }
}
///General PWM Timer 9 (32-bit Enhanced)
pub use self::gpt328 as gpt329;
///General PWM Timer 10 (32-bit Enhanced)
pub type GPT3210 = crate::Periph<gpt328::RegisterBlock, 0x4007_8a00>;
impl core::fmt::Debug for GPT3210 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT3210").finish()
    }
}
///General PWM Timer 10 (32-bit Enhanced)
pub use self::gpt328 as gpt3210;
///General PWM Timer 11 (32-bit Enhanced)
pub type GPT3211 = crate::Periph<gpt328::RegisterBlock, 0x4007_8b00>;
impl core::fmt::Debug for GPT3211 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT3211").finish()
    }
}
///General PWM Timer 11 (32-bit Enhanced)
pub use self::gpt328 as gpt3211;
///General PWM Timer 12 (32-bit Enhanced)
pub type GPT3212 = crate::Periph<gpt328::RegisterBlock, 0x4007_8c00>;
impl core::fmt::Debug for GPT3212 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT3212").finish()
    }
}
///General PWM Timer 12 (32-bit Enhanced)
pub use self::gpt328 as gpt3212;
///General PWM Timer 13 (32-bit Enhanced)
pub type GPT3213 = crate::Periph<gpt328::RegisterBlock, 0x4007_8d00>;
impl core::fmt::Debug for GPT3213 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT3213").finish()
    }
}
///General PWM Timer 13 (32-bit Enhanced)
pub use self::gpt328 as gpt3213;
///Realtime Clock
pub type RTC = crate::Periph<rtc::RegisterBlock, 0x4004_4000>;
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///Realtime Clock
pub mod rtc;
///Serial Sound Interface Enhanced (SSIE)
pub type SSIE0 = crate::Periph<ssie0::RegisterBlock, 0x4004_e000>;
impl core::fmt::Debug for SSIE0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SSIE0").finish()
    }
}
///Serial Sound Interface Enhanced (SSIE)
pub mod ssie0;
///Serial Sound Interface Enhanced (SSIE)
pub type SSIE1 = crate::Periph<ssie0::RegisterBlock, 0x4004_e100>;
impl core::fmt::Debug for SSIE1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SSIE1").finish()
    }
}
///Serial Sound Interface Enhanced (SSIE)
pub use self::ssie0 as ssie1;
///USB 2.0 FS Module
pub type USBFS = crate::Periph<usbfs::RegisterBlock, 0x4009_0000>;
impl core::fmt::Debug for USBFS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBFS").finish()
    }
}
///USB 2.0 FS Module
pub mod usbfs;
///Sampling Rate Converter RAM
pub type SRCRAM = crate::Periph<srcram::RegisterBlock, 0x4004_8000>;
impl core::fmt::Debug for SRCRAM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRCRAM").finish()
    }
}
///Sampling Rate Converter RAM
pub mod srcram;
///Sampling Rate Converter
pub type SRC = crate::Periph<src::RegisterBlock, 0x4004_dff0>;
impl core::fmt::Debug for SRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRC").finish()
    }
}
///Sampling Rate Converter
pub mod src;
///Interrupt Controller
pub type ICU = crate::Periph<icu::RegisterBlock, 0x4000_6000>;
impl core::fmt::Debug for ICU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ICU").finish()
    }
}
///Interrupt Controller
pub mod icu;
///SRAM Control
pub type SRAM = crate::Periph<sram::RegisterBlock, 0x4000_2000>;
impl core::fmt::Debug for SRAM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRAM").finish()
    }
}
///SRAM Control
pub mod sram;
///PWM Delay Generation Circuit
pub type GPT_ODC = crate::Periph<gpt_odc::RegisterBlock, 0x4007_b000>;
impl core::fmt::Debug for GPT_ODC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPT_ODC").finish()
    }
}
///PWM Delay Generation Circuit
pub mod gpt_odc;
///Asynchronous General purpose Timer 0
pub type AGT0 = crate::Periph<agt0::RegisterBlock, 0x4008_4000>;
impl core::fmt::Debug for AGT0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AGT0").finish()
    }
}
///Asynchronous General purpose Timer 0
pub mod agt0;
///Asynchronous General purpose Timer 1
pub type AGT1 = crate::Periph<agt0::RegisterBlock, 0x4008_4100>;
impl core::fmt::Debug for AGT1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AGT1").finish()
    }
}
///Asynchronous General purpose Timer 1
pub use self::agt0 as agt1;
///Flash Cache
pub type FCACHE = crate::Periph<fcache::RegisterBlock, 0x4001_c000>;
impl core::fmt::Debug for FCACHE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FCACHE").finish()
    }
}
///Flash Cache
pub mod fcache;
///BUS Control
pub type BUS = crate::Periph<bus::RegisterBlock, 0x4000_3000>;
impl core::fmt::Debug for BUS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BUS").finish()
    }
}
///BUS Control
pub mod bus;
///12-bit D/A converter
pub type DAC12 = crate::Periph<dac12::RegisterBlock, 0x4005_e000>;
impl core::fmt::Debug for DAC12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DAC12").finish()
    }
}
///12-bit D/A converter
pub mod dac12;
///ADC-DAC Interface
pub type AMI = crate::Periph<ami::RegisterBlock, 0x4005_f000>;
impl core::fmt::Debug for AMI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AMI").finish()
    }
}
///ADC-DAC Interface
pub mod ami;
///JPEG Codec
pub type JPEG = crate::Periph<jpeg::RegisterBlock, 0x400e_6000>;
impl core::fmt::Debug for JPEG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("JPEG").finish()
    }
}
///JPEG Codec
pub mod jpeg;
///Port Output Enable Module for GPT
pub type POEG = crate::Periph<poeg::RegisterBlock, 0x4004_2000>;
impl core::fmt::Debug for POEG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("POEG").finish()
    }
}
///Port Output Enable Module for GPT
pub mod poeg;
///Infrared Data Association
pub type IRDA = crate::Periph<irda::RegisterBlock, 0x4007_0f00>;
impl core::fmt::Debug for IRDA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IRDA").finish()
    }
}
///Infrared Data Association
pub mod irda;
///CAN0 Module
pub type CAN0 = crate::Periph<can0::RegisterBlock, 0x4005_0000>;
impl core::fmt::Debug for CAN0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CAN0").finish()
    }
}
///CAN0 Module
pub mod can0;
///CAN1 Module
pub type CAN1 = crate::Periph<can0::RegisterBlock, 0x4005_1000>;
impl core::fmt::Debug for CAN1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CAN1").finish()
    }
}
///CAN1 Module
pub use self::can0 as can1;
///Parallel Data Capture Unit
pub type PDC = crate::Periph<pdc::RegisterBlock, 0x4009_4000>;
impl core::fmt::Debug for PDC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PDC").finish()
    }
}
///Parallel Data Capture Unit
pub mod pdc;
///Quad-SPI
pub type QSPI = crate::Periph<qspi::RegisterBlock, 0x6400_0000>;
impl core::fmt::Debug for QSPI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("QSPI").finish()
    }
}
///Quad-SPI
pub mod qspi;
///Memory Mirror Function
pub type MMF = crate::Periph<mmf::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for MMF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MMF").finish()
    }
}
///Memory Mirror Function
pub mod mmf;
///Direct memory access controller 0
pub type DMAC0 = crate::Periph<dmac0::RegisterBlock, 0x4000_5000>;
impl core::fmt::Debug for DMAC0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC0").finish()
    }
}
///Direct memory access controller 0
pub mod dmac0;
///Direct memory access controller 1
pub type DMAC1 = crate::Periph<dmac0::RegisterBlock, 0x4000_5040>;
impl core::fmt::Debug for DMAC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC1").finish()
    }
}
///Direct memory access controller 1
pub use self::dmac0 as dmac1;
///Direct memory access controller 2
pub type DMAC2 = crate::Periph<dmac0::RegisterBlock, 0x4000_5080>;
impl core::fmt::Debug for DMAC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC2").finish()
    }
}
///Direct memory access controller 2
pub use self::dmac0 as dmac2;
///Direct memory access controller 3
pub type DMAC3 = crate::Periph<dmac0::RegisterBlock, 0x4000_50c0>;
impl core::fmt::Debug for DMAC3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC3").finish()
    }
}
///Direct memory access controller 3
pub use self::dmac0 as dmac3;
///Direct memory access controller 4
pub type DMAC4 = crate::Periph<dmac0::RegisterBlock, 0x4000_5100>;
impl core::fmt::Debug for DMAC4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC4").finish()
    }
}
///Direct memory access controller 4
pub use self::dmac0 as dmac4;
///Direct memory access controller 5
pub type DMAC5 = crate::Periph<dmac0::RegisterBlock, 0x4000_5140>;
impl core::fmt::Debug for DMAC5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC5").finish()
    }
}
///Direct memory access controller 5
pub use self::dmac0 as dmac5;
///Direct memory access controller 6
pub type DMAC6 = crate::Periph<dmac0::RegisterBlock, 0x4000_5180>;
impl core::fmt::Debug for DMAC6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC6").finish()
    }
}
///Direct memory access controller 6
pub use self::dmac0 as dmac6;
///Direct memory access controller 7
pub type DMAC7 = crate::Periph<dmac0::RegisterBlock, 0x4000_51c0>;
impl core::fmt::Debug for DMAC7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMAC7").finish()
    }
}
///Direct memory access controller 7
pub use self::dmac0 as dmac7;
///DMAC Module Activation
pub type DMA = crate::Periph<dma::RegisterBlock, 0x4000_5200>;
impl core::fmt::Debug for DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA").finish()
    }
}
///DMAC Module Activation
pub mod dma;
///Data Transfer Controller
pub type DTC = crate::Periph<dtc::RegisterBlock, 0x4000_5400>;
impl core::fmt::Debug for DTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DTC").finish()
    }
}
///Data Transfer Controller
pub mod dtc;
///Debug Function
pub type DBG = crate::Periph<dbg::RegisterBlock, 0x4001_b000>;
impl core::fmt::Debug for DBG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DBG").finish()
    }
}
///Debug Function
pub mod dbg;
///Temperature Sensor
pub type TSN = crate::Periph<tsn::RegisterBlock, 0x4005_d000>;
impl core::fmt::Debug for TSN {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TSN").finish()
    }
}
///Temperature Sensor
pub mod tsn;
///High-Speed Analog Comparator 0
pub type ACMPHS0 = crate::Periph<acmphs0::RegisterBlock, 0x4008_5000>;
impl core::fmt::Debug for ACMPHS0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS0").finish()
    }
}
///High-Speed Analog Comparator 0
pub mod acmphs0;
///High-Speed Analog Comparator 1
pub type ACMPHS1 = crate::Periph<acmphs1::RegisterBlock, 0x4008_5100>;
impl core::fmt::Debug for ACMPHS1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS1").finish()
    }
}
///High-Speed Analog Comparator 1
pub mod acmphs1;
///High-Speed Analog Comparator 2
pub type ACMPHS2 = crate::Periph<acmphs1::RegisterBlock, 0x4008_5200>;
impl core::fmt::Debug for ACMPHS2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS2").finish()
    }
}
///High-Speed Analog Comparator 2
pub use self::acmphs1 as acmphs2;
///High-Speed Analog Comparator 3
pub type ACMPHS3 = crate::Periph<acmphs1::RegisterBlock, 0x4008_5300>;
impl core::fmt::Debug for ACMPHS3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS3").finish()
    }
}
///High-Speed Analog Comparator 3
pub use self::acmphs1 as acmphs3;
///High-Speed Analog Comparator 4
pub type ACMPHS4 = crate::Periph<acmphs1::RegisterBlock, 0x4008_5400>;
impl core::fmt::Debug for ACMPHS4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS4").finish()
    }
}
///High-Speed Analog Comparator 4
pub use self::acmphs1 as acmphs4;
///High-Speed Analog Comparator 5
pub type ACMPHS5 = crate::Periph<acmphs1::RegisterBlock, 0x4008_5500>;
impl core::fmt::Debug for ACMPHS5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ACMPHS5").finish()
    }
}
///High-Speed Analog Comparator 5
pub use self::acmphs1 as acmphs5;
///Event Link Controller
pub type ELC = crate::Periph<elc::RegisterBlock, 0x4004_1000>;
impl core::fmt::Debug for ELC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ELC").finish()
    }
}
///Event Link Controller
pub mod elc;
///Watchdog Timer
pub type WDT = crate::Periph<wdt::RegisterBlock, 0x4004_4200>;
impl core::fmt::Debug for WDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WDT").finish()
    }
}
///Watchdog Timer
pub mod wdt;
///Independent Watchdog Timer
pub type IWDT = crate::Periph<iwdt::RegisterBlock, 0x4004_4400>;
impl core::fmt::Debug for IWDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IWDT").finish()
    }
}
///Independent Watchdog Timer
pub mod iwdt;
///Key Interrupt Function
pub type KINT = crate::Periph<kint::RegisterBlock, 0x4008_0000>;
impl core::fmt::Debug for KINT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KINT").finish()
    }
}
///Key Interrupt Function
pub mod kint;
///Data Operation Circuit
pub type DOC = crate::Periph<doc::RegisterBlock, 0x4005_4100>;
impl core::fmt::Debug for DOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DOC").finish()
    }
}
///Data Operation Circuit
pub mod doc;
///Clock Frequency Accuracy Measurement Circuit
pub type CAC = crate::Periph<cac::RegisterBlock, 0x4004_4600>;
impl core::fmt::Debug for CAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CAC").finish()
    }
}
///Clock Frequency Accuracy Measurement Circuit
pub mod cac;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///PORT0
    pub PORT0: PORT0,
    ///PORT1
    pub PORT1: PORT1,
    ///PORT2
    pub PORT2: PORT2,
    ///PORT3
    pub PORT3: PORT3,
    ///PORT4
    pub PORT4: PORT4,
    ///PORT5
    pub PORT5: PORT5,
    ///PORT6
    pub PORT6: PORT6,
    ///PORT7
    pub PORT7: PORT7,
    ///PORT8
    pub PORT8: PORT8,
    ///PORT9
    pub PORT9: PORT9,
    ///PORTA
    pub PORTA: PORTA,
    ///PORTB
    pub PORTB: PORTB,
    ///PFS
    pub PFS: PFS,
    ///PMISC
    pub PMISC: PMISC,
    ///SPI0
    pub SPI0: SPI0,
    ///SPI1
    pub SPI1: SPI1,
    ///GPT_OPS
    pub GPT_OPS: GPT_OPS,
    ///GPT32EH0
    pub GPT32EH0: GPT32EH0,
    ///GPT32EH1
    pub GPT32EH1: GPT32EH1,
    ///GPT32EH2
    pub GPT32EH2: GPT32EH2,
    ///GPT32EH3
    pub GPT32EH3: GPT32EH3,
    ///GPT32E4
    pub GPT32E4: GPT32E4,
    ///GPT32E5
    pub GPT32E5: GPT32E5,
    ///GPT32E6
    pub GPT32E6: GPT32E6,
    ///GPT32E7
    pub GPT32E7: GPT32E7,
    ///GLCDC
    pub GLCDC: GLCDC,
    ///DRW
    pub DRW: DRW,
    ///USBHS
    pub USBHS: USBHS,
    ///SCI0
    pub SCI0: SCI0,
    ///SCI1
    pub SCI1: SCI1,
    ///SCI2
    pub SCI2: SCI2,
    ///SCI3
    pub SCI3: SCI3,
    ///SCI4
    pub SCI4: SCI4,
    ///SCI5
    pub SCI5: SCI5,
    ///SCI6
    pub SCI6: SCI6,
    ///SCI7
    pub SCI7: SCI7,
    ///SCI8
    pub SCI8: SCI8,
    ///SCI9
    pub SCI9: SCI9,
    ///IIC0
    pub IIC0: IIC0,
    ///IIC1
    pub IIC1: IIC1,
    ///IIC2
    pub IIC2: IIC2,
    ///SYSTEM
    pub SYSTEM: SYSTEM,
    ///EDMAC0
    pub EDMAC0: EDMAC0,
    ///ETHERC0
    pub ETHERC0: ETHERC0,
    ///PTPEDMAC
    pub PTPEDMAC: PTPEDMAC,
    ///EPTPC
    pub EPTPC: EPTPC,
    ///EPTPC0
    pub EPTPC0: EPTPC0,
    ///EPTPC_CFG
    pub EPTPC_CFG: EPTPC_CFG,
    ///SDHI0
    pub SDHI0: SDHI0,
    ///SDHI1
    pub SDHI1: SDHI1,
    ///CRC
    pub CRC: CRC,
    ///CTSU
    pub CTSU: CTSU,
    ///MMPU
    pub MMPU: MMPU,
    ///SMPU
    pub SMPU: SMPU,
    ///SPMON
    pub SPMON: SPMON,
    ///ADC120
    pub ADC120: ADC120,
    ///ADC121
    pub ADC121: ADC121,
    ///MSTP
    pub MSTP: MSTP,
    ///GPT328
    pub GPT328: GPT328,
    ///GPT329
    pub GPT329: GPT329,
    ///GPT3210
    pub GPT3210: GPT3210,
    ///GPT3211
    pub GPT3211: GPT3211,
    ///GPT3212
    pub GPT3212: GPT3212,
    ///GPT3213
    pub GPT3213: GPT3213,
    ///RTC
    pub RTC: RTC,
    ///SSIE0
    pub SSIE0: SSIE0,
    ///SSIE1
    pub SSIE1: SSIE1,
    ///USBFS
    pub USBFS: USBFS,
    ///SRCRAM
    pub SRCRAM: SRCRAM,
    ///SRC
    pub SRC: SRC,
    ///ICU
    pub ICU: ICU,
    ///SRAM
    pub SRAM: SRAM,
    ///GPT_ODC
    pub GPT_ODC: GPT_ODC,
    ///AGT0
    pub AGT0: AGT0,
    ///AGT1
    pub AGT1: AGT1,
    ///FCACHE
    pub FCACHE: FCACHE,
    ///BUS
    pub BUS: BUS,
    ///DAC12
    pub DAC12: DAC12,
    ///AMI
    pub AMI: AMI,
    ///JPEG
    pub JPEG: JPEG,
    ///POEG
    pub POEG: POEG,
    ///IRDA
    pub IRDA: IRDA,
    ///CAN0
    pub CAN0: CAN0,
    ///CAN1
    pub CAN1: CAN1,
    ///PDC
    pub PDC: PDC,
    ///QSPI
    pub QSPI: QSPI,
    ///MMF
    pub MMF: MMF,
    ///DMAC0
    pub DMAC0: DMAC0,
    ///DMAC1
    pub DMAC1: DMAC1,
    ///DMAC2
    pub DMAC2: DMAC2,
    ///DMAC3
    pub DMAC3: DMAC3,
    ///DMAC4
    pub DMAC4: DMAC4,
    ///DMAC5
    pub DMAC5: DMAC5,
    ///DMAC6
    pub DMAC6: DMAC6,
    ///DMAC7
    pub DMAC7: DMAC7,
    ///DMA
    pub DMA: DMA,
    ///DTC
    pub DTC: DTC,
    ///DBG
    pub DBG: DBG,
    ///TSN
    pub TSN: TSN,
    ///ACMPHS0
    pub ACMPHS0: ACMPHS0,
    ///ACMPHS1
    pub ACMPHS1: ACMPHS1,
    ///ACMPHS2
    pub ACMPHS2: ACMPHS2,
    ///ACMPHS3
    pub ACMPHS3: ACMPHS3,
    ///ACMPHS4
    pub ACMPHS4: ACMPHS4,
    ///ACMPHS5
    pub ACMPHS5: ACMPHS5,
    ///ELC
    pub ELC: ELC,
    ///WDT
    pub WDT: WDT,
    ///IWDT
    pub IWDT: IWDT,
    ///KINT
    pub KINT: KINT,
    ///DOC
    pub DOC: DOC,
    ///CAC
    pub CAC: CAC,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PORT0: PORT0::steal(),
            PORT1: PORT1::steal(),
            PORT2: PORT2::steal(),
            PORT3: PORT3::steal(),
            PORT4: PORT4::steal(),
            PORT5: PORT5::steal(),
            PORT6: PORT6::steal(),
            PORT7: PORT7::steal(),
            PORT8: PORT8::steal(),
            PORT9: PORT9::steal(),
            PORTA: PORTA::steal(),
            PORTB: PORTB::steal(),
            PFS: PFS::steal(),
            PMISC: PMISC::steal(),
            SPI0: SPI0::steal(),
            SPI1: SPI1::steal(),
            GPT_OPS: GPT_OPS::steal(),
            GPT32EH0: GPT32EH0::steal(),
            GPT32EH1: GPT32EH1::steal(),
            GPT32EH2: GPT32EH2::steal(),
            GPT32EH3: GPT32EH3::steal(),
            GPT32E4: GPT32E4::steal(),
            GPT32E5: GPT32E5::steal(),
            GPT32E6: GPT32E6::steal(),
            GPT32E7: GPT32E7::steal(),
            GLCDC: GLCDC::steal(),
            DRW: DRW::steal(),
            USBHS: USBHS::steal(),
            SCI0: SCI0::steal(),
            SCI1: SCI1::steal(),
            SCI2: SCI2::steal(),
            SCI3: SCI3::steal(),
            SCI4: SCI4::steal(),
            SCI5: SCI5::steal(),
            SCI6: SCI6::steal(),
            SCI7: SCI7::steal(),
            SCI8: SCI8::steal(),
            SCI9: SCI9::steal(),
            IIC0: IIC0::steal(),
            IIC1: IIC1::steal(),
            IIC2: IIC2::steal(),
            SYSTEM: SYSTEM::steal(),
            EDMAC0: EDMAC0::steal(),
            ETHERC0: ETHERC0::steal(),
            PTPEDMAC: PTPEDMAC::steal(),
            EPTPC: EPTPC::steal(),
            EPTPC0: EPTPC0::steal(),
            EPTPC_CFG: EPTPC_CFG::steal(),
            SDHI0: SDHI0::steal(),
            SDHI1: SDHI1::steal(),
            CRC: CRC::steal(),
            CTSU: CTSU::steal(),
            MMPU: MMPU::steal(),
            SMPU: SMPU::steal(),
            SPMON: SPMON::steal(),
            ADC120: ADC120::steal(),
            ADC121: ADC121::steal(),
            MSTP: MSTP::steal(),
            GPT328: GPT328::steal(),
            GPT329: GPT329::steal(),
            GPT3210: GPT3210::steal(),
            GPT3211: GPT3211::steal(),
            GPT3212: GPT3212::steal(),
            GPT3213: GPT3213::steal(),
            RTC: RTC::steal(),
            SSIE0: SSIE0::steal(),
            SSIE1: SSIE1::steal(),
            USBFS: USBFS::steal(),
            SRCRAM: SRCRAM::steal(),
            SRC: SRC::steal(),
            ICU: ICU::steal(),
            SRAM: SRAM::steal(),
            GPT_ODC: GPT_ODC::steal(),
            AGT0: AGT0::steal(),
            AGT1: AGT1::steal(),
            FCACHE: FCACHE::steal(),
            BUS: BUS::steal(),
            DAC12: DAC12::steal(),
            AMI: AMI::steal(),
            JPEG: JPEG::steal(),
            POEG: POEG::steal(),
            IRDA: IRDA::steal(),
            CAN0: CAN0::steal(),
            CAN1: CAN1::steal(),
            PDC: PDC::steal(),
            QSPI: QSPI::steal(),
            MMF: MMF::steal(),
            DMAC0: DMAC0::steal(),
            DMAC1: DMAC1::steal(),
            DMAC2: DMAC2::steal(),
            DMAC3: DMAC3::steal(),
            DMAC4: DMAC4::steal(),
            DMAC5: DMAC5::steal(),
            DMAC6: DMAC6::steal(),
            DMAC7: DMAC7::steal(),
            DMA: DMA::steal(),
            DTC: DTC::steal(),
            DBG: DBG::steal(),
            TSN: TSN::steal(),
            ACMPHS0: ACMPHS0::steal(),
            ACMPHS1: ACMPHS1::steal(),
            ACMPHS2: ACMPHS2::steal(),
            ACMPHS3: ACMPHS3::steal(),
            ACMPHS4: ACMPHS4::steal(),
            ACMPHS5: ACMPHS5::steal(),
            ELC: ELC::steal(),
            WDT: WDT::steal(),
            IWDT: IWDT::steal(),
            KINT: KINT::steal(),
            DOC: DOC::steal(),
            CAC: CAC::steal(),
        }
    }
}
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
#[cfg(all(feature = "fsp", feature = "cortex-m-rt-device"))]
compile_error!("Cannot enable both `fsp` and `cortex-m-rt-device` features at the same time.");
#[cfg(feature = "rt")]
impl Interrupt {
    pub const fn try_from_u16(n: u16) -> Option<Self> {
        assert!(__INTERRUPTS.len() < u16::MAX as usize);
        if n >= __INTERRUPTS.len() as u16 {
            return None;
        }
        Some(unsafe { ::core::mem::transmute(n as u16) })
    }
}
#[cfg(feature = "rt")]
#[derive(Debug)]
pub struct InvalidInterruptNumber;
#[cfg(feature = "rt")]
impl TryFrom<u16> for Interrupt {
    type Error = InvalidInterruptNumber;
    fn try_from(value: u16) -> Result<Self, Self::Error> {
        Interrupt::try_from_u16(value).ok_or(InvalidInterruptNumber)
    }
}
#[cfg(feature = "rt")]
impl core::error::Error for InvalidInterruptNumber {}
#[cfg(feature = "rt")]
impl core::fmt::Display for InvalidInterruptNumber {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "Invalid interrupt number")
    }
}
